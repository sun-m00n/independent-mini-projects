(() => { var N = (e, t) => e.reduce((n, s) => n.then(m => t(s).then(u => m.concat([u]))), Promise.resolve([])); var k = e => { let t = new DataTransfer; return e.forEach(n => t.items.add(n)), Object.defineProperty(t, "items", { value: e.map(n => (n.getAsFile = () => n, n)) }), t }; var G = (e, t) => document.documentElement.addEventListener(e, t, !0); var X = (e, t) => { let n = k(t); e.files = n.files }; var L = (e, t, n = {}, s = {}) => { let { bubbles: m = !0, detail: u, cancelable: a = !0 } = s, d = new CustomEvent(t, { bubbles: m, cancelable: a, detail: u }); return Object.assign(d, n), e.dispatchEvent(d), d }; var pe = ["x", "y", "screenX", "screenY", "layerX", "layerY", "pageX", "pageY", "offsetX", "offsetY", "clientX", "clientY"], _ = (e, { didIntercept: t, shouldHandleChange: n, shouldHandleDrop: s }, m) => { let u = (a, d) => N(Array.from(a), g => e(g, d)); G("change", a => { let { target: d } = a; if (d.ignoreChangeEvent || a.$cropguide) return; let g = n(a); !g || (t(a), a.stopImmediatePropagation(), u(d.files, g).then(o => { m("processed selected files", o), d.ignoreChangeEvent = !0, X(d, o.filter(Boolean)), delete d.ignoreChangeEvent; let p = L(d, "change", { $cropguide: !0 }); m("dispatched CustomEvent", [d, p]) })) }), G("drop", a => { if (a.$cropguide) return; let d = s(a); if (!d) return; t(a); let { target: g } = a; a.preventDefault(), a.stopImmediatePropagation(); let o = pe.reduce((p, h) => (p[h] = a[h], p), {}); u(a.dataTransfer.files, d).then(p => { m("processed dropped files", p); let h = k(p.filter(Boolean)), T = L(g, "drop", { ...o, dataTransfer: { effectAllowed: "all", types: ["Files"], files: h.files, items: h.items, getData: () => "" }, $cropguide: !0 }); m("dispatched CustomEvent", [g, T]) }) }) }; var q = () => window && "DataTransfer" in window; var U = (e, { parent: t, onerror: n }) => { let s = document.createElement("script"); return s.defer = !0, s.async = !0, s.src = e, s.onerror = n, (t || document.head).append(s), s }; var O = e => e && /input/i.test(e.tagName) && e.type === "file"; var D = e => e && e.type && /png|jpeg|gif|bmp|webp/.test(e.type); var V = e => !(!O(e.target) || !e.target.files.length || !Array.from(e.target.files).some(D)); var W = e => !(O(e.target) || !e.dataTransfer || !e.dataTransfer.files.length || !Array.from(e.dataTransfer.files).some(D)); var ue = e => e.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, "$1."), J = e => { let t = Date.now(), n = "CropGuide"; return e ? (...s) => { let m = Date.now() - t, u = `${ue(m)}ms`.padStart(8, " "), a = ""; typeof s[0] == "string" ? (a = u + " " + n + " " + s[0], params = s.splice(1)) : (a = u, params = [...s]), params.length ? console.log(a, params) : console.log(a) } : () => { } }; var K = "application/json", A = (e, t = {}, { method: n = "POST" } = {}) => fetch(e, { headers: { Accept: K, "Content-Type": K }, method: n, body: JSON.stringify(t) }).catch(console.log); var Q = (e, t) => { if (t === "html" || e.matches(t)) return !0; let s = document.querySelector(t); return s ? s.contains(e) : !1 }; var Z = e => new File([e], e.name, { type: e.type, lastModified: e.lastModified }); var ee = () => { let [e, t, n] = getComputedStyle(document.documentElement).backgroundColor.match(/[0-9]+/g).map(m => parseInt(m, 10)); return .2126 * e + .7152 * t + .0722 * n > 100 }; var te = () => { try { return localStorage.getItem("cgdebug") === "1" } catch (e) { } }; var oe = (e, t) => (console.log(e, t), !t || !t.length ? !0 : e && e.type && t.includes(e.type)); ((e, t, { hookId: n, apiURL: s, localeURL: m, clientURL: u }) => { let d = new URL(t.currentScript.src).searchParams, g = d.get("debug") !== null || te(d), o = J(g); if (!q()) return o("not supported on this browser"); let p = d.get("c"); if (!p) return o("clientId not found"); let h = e[n], T = []; if (h) { if (h.fields) T = h.fields.map(r => typeof r == "string" ? { selector: r } : r), e[n] = void 0, o("local fields config loaded", T); else if (typeof h == "object") return o("client already initialised") } let y = (r, i) => L(t.documentElement, `${n}:${r}`, void 0, { detail: i }); y("init"), o("init", p); let E, j, H, l, re = (r = "auto") => { if (r !== "auto") return r.toLowerCase() || "en"; let i = (t.documentElement.lang || "en").substring(0, 2).toLowerCase(); return /^(en|es|fr|de|ru|zh)$/i.test(i) ? i : "en" }, B = (r, i, w) => { if (!w(i)) return o(`skip ${i.type} event`, i), !1; let f = r.find(({ selector: x }) => Q(i.target, x)); return !f || f.field.disabled && !g ? (o(`skip ${i.type} event`, i), !1) : (o(`handle ${i.type} event`, i, f), f) }, ne = (r, i) => ({ selector: i.selector, field: { ...r.field, ...i.field }, editor: { ...r.editor, ...i.editor } }), R = () => { let { banner: r } = E, i = T.length ? T.map(c => { let $ = E.fields.find(v => v.selector === c.selector) || E.fields.find(v => v.selector === "html"); return ne($, c) }) : E.fields; o("fields config", i); let w = ee(), { userAgent: f, maxTouchPoints: x, platform: ie } = navigator, se = /^mac/i.test(ie), F = /iPhone|iPad|iPod/.test(f) || se && x >= 1; if (F) { let c = t.createElement("style"); c.textContent = ".CropGuideDocumentLock,.CropGuideDocumentLock body {height: var(--crop-guide-document-height);overflow-y: hidden;box-sizing: border-box;}.CropGuideDocumentLock body {position:relative;}.CropGuideDocumentLock .CropGuideFrame {height: 100% !important;}", t.head.append(c) } let P, I = () => t.documentElement.style.setProperty("--crop-guide-document-height", `${window.innerHeight}px`), ae = () => { o("will show editor"), l.style.pointerEvents = "all", l.style.width = "100%", l.style.height = "100vh", !!F && I() }, ce = () => { o("did show editor"), y("open"), !!F && (P === void 0 && (P = e.scrollY), t.documentElement.classList.add("CropGuideDocumentLock"), I(), e.addEventListener("resize", I)) }, de = () => { o("will hide editor"), !!F && (e.removeEventListener("resize", I), t.documentElement.classList.remove("CropGuideDocumentLock"), e.scrollTo(0, P), P = void 0) }, le = () => { o("did hide editor"), y("close"), l.style.pointerEvents = "none", l.style.width = 0, l.style.height = 0 }; _((c, $) => new Promise(v => { if (!D(c) || !oe(c, $.field.accept)) return o("ignore", c), y("ignore", { src: c }), v(c); o("edit", c); let me = { locale: j, banner: r, pageIsBright: w, willShowEditor: ae, didShowEditor: ce, willHideEditor: de, didHideEditor: le }, Y = () => { l.removeEventListener("load", Y), H(c, { log: o, env: me, requirements: $ }).then(b => { let C = Z(b); o("processed", C), A(`${s}/meter`, { clientId: p }), y("process", { src: c, dest: C }), v(C) }).catch(b => { let C = b; b.hasOwnProperty("message") ? C = { error: b.message + " " + b.stack } : typeof b == "string" && (C = { error: b }); let { error: S } = C; if (/image too small/i.test(S)) return o("image too small", c), y("invalid", { src: c }), v(); o("error", S), A(`${s}/report`, { clientId: p, error: S }), y("error", { src: c, error: S }), v(c) }) }; l.isConnected ? Y() : (l.addEventListener("load", Y), document.body.append(l)) }), { didIntercept: c => y("intercept", c), shouldHandleChange: c => B(i, c, V), shouldHandleDrop: c => B(i, c, W) }, o), y("load") }, z = (r, i, w) => { if (!r) { o(`wait for ${i} to load`); return } w() }; e[n] = { _setLocale: r => { o("locale loaded", r), j = r, z(H, "editor", R) }, _setEditor: r => { o("client loaded"), H = r, z(j, "locale", R) } }; let M = s + "/config/" + p; o("load config", M), fetch(M).then(r => r.text()).then(r => { o("config loaded"); try { E = JSON.parse(r, (f, x) => x === null ? void 0 : x) } catch (f) { o("failed to parse config", r); return } if (o("config parsed", E), E.status === "Inactive") { o("inactive", E); return } let i = re(E.locale); o("inject locale", m, i), U(m + `/${i}.js`, { onerror: f => o("locale inject error", f || {}) }); let w = "html .pintura-editor{--color-primary:#6418e6;--color-primary-dark:#4e18aa;--color-primary-text:#faf7ff} html .pintura-editor .PinturaButtonExport{color:rgb(var(--color-background))!important;background:rgb(var(--color-foreground))!important}"; l = t.createElement("iframe"), l.onerror = f => o("iframe load error", f), l.allowtransparency = !0, l.className = "CropGuideFrame", l.style.cssText = "position:fixed;left:0;top:0;width:0;height:0;border:0;z-index:2147483647;pointer-events:none;touch-action:manipulation;user-select:none;", o("inject client", u), l.srcdoc = '<!DOCTYPE html><html lang="' + i + '"><meta charset="utf-8"><title>crop.guide</title><style>' + w + '</style><script src="' + u + '"><\/script></html>', o("append client frame"), t.body.append(l) }).catch(r => o("config load error", r)) })(window, document, { hookId: "$cropguide", apiURL: "https://app.crop.guide/api", localeURL: "https://cdn.crop.guide/locale", clientURL: "https://cdn.crop.guide/client/l.js" }); })();
